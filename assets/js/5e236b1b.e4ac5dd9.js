"use strict";(self.webpackChunkverkle_dev=self.webpackChunkverkle_dev||[]).push([[981],{3905:(e,a,t)=>{t.d(a,{Zo:()=>o,kt:()=>u});var r=t(7294);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function p(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var m=r.createContext({}),l=function(e){var a=r.useContext(m),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},o=function(e){var a=l(e.components);return r.createElement(m.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},k=r.forwardRef((function(e,a){var t=e.components,n=e.mdxType,s=e.originalType,m=e.parentName,o=p(e,["components","mdxType","originalType","parentName"]),k=l(t),u=n,h=k["".concat(m,".").concat(u)]||k[u]||c[u]||s;return t?r.createElement(h,i(i({ref:a},o),{},{components:t})):r.createElement(h,i({ref:a},o))}));function u(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var s=t.length,i=new Array(s);i[0]=k;var p={};for(var m in a)hasOwnProperty.call(a,m)&&(p[m]=a[m]);p.originalType=e,p.mdxType="string"==typeof e?e:n,i[1]=p;for(var l=2;l<s;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}k.displayName="MDXCreateElement"},3853:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>m,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>p,toc:()=>l});var r=t(7462),n=(t(7294),t(3905));const s={},i="Merkle Patricia Trie",p={unversionedId:"concepts/data_structures/merkle_patricia_trie",id:"concepts/data_structures/merkle_patricia_trie",title:"Merkle Patricia Trie",description:"The Merkle Patricia Trie currently used in Ethereum is a modified fusion of the merkle tree and patricia trie (also known as a radix tree or prefix tree).",source:"@site/docs/02-concepts/01-data_structures/01-merkle_patricia_trie.md",sourceDirName:"02-concepts/01-data_structures",slug:"/concepts/data_structures/merkle_patricia_trie",permalink:"/docs/concepts/data_structures/merkle_patricia_trie",draft:!1,editUrl:"https://github.com/ethereum/verkle-dev-website/blob/master/docs/02-concepts/01-data_structures/01-merkle_patricia_trie.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Merkle Trees",permalink:"/docs/concepts/data_structures/merkle_trees"},next:{title:"Elliptic Curves",permalink:"/docs/concepts/math/elliptic curves"}},m={},l=[{value:"Performance Issues",id:"performance-issues",level:2},{value:"More Reading",id:"more-reading",level:2}],o={toc:l};function c(e){let{components:a,...t}=e;return(0,n.kt)("wrapper",(0,r.Z)({},o,t,{components:a,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"merkle-patricia-trie"},"Merkle Patricia Trie"),(0,n.kt)("p",null,"The Merkle Patricia Trie currently used in Ethereum is a modified fusion of the merkle tree and ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Radix_tree"},"patricia trie")," (also known as a radix tree or prefix tree)."),(0,n.kt)("p",null,"It turns out that merkle trees are great for verifying a large list of static data elements, but not as great for storing the Ethereum world state. In a merkle tree, a single leaf node change requires rehashing every parent node, an ",(0,n.kt)("span",{parentName:"p",className:"math math-inline"},(0,n.kt)("span",{parentName:"span",className:"katex"},(0,n.kt)("span",{parentName:"span",className:"katex-mathml"},(0,n.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,n.kt)("semantics",{parentName:"math"},(0,n.kt)("mrow",{parentName:"semantics"},(0,n.kt)("mi",{parentName:"mrow"},"O"),(0,n.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,n.kt)("mi",{parentName:"mrow"},"log"),(0,n.kt)("mo",{parentName:"mrow"},"\u2061"),(0,n.kt)("mi",{parentName:"mrow"},"N"),(0,n.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,n.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(\\log N)")))),(0,n.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,n.kt)("span",{parentName:"span",className:"base"},(0,n.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,n.kt)("span",{parentName:"span",className:"mopen"},"("),(0,n.kt)("span",{parentName:"span",className:"mop"},"lo",(0,n.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,n.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"),(0,n.kt)("span",{parentName:"span",className:"mclose"},")")))))," operation. We can do better and take advantage of the fact that the world state is a set of key-value pairs where the key is a fixed-size 160-bit string (the address)."),(0,n.kt)("p",null,"A patricia trie, in which the key is encoded nibble-by-nibble into the path to the leaf node, enables us (with some adjustments) to bound and reduce the number of parent leaves. It also offers convenient methods of accessing specific key-value pairs. However it lacks the cryptographic guarantees of data integrity that the Merkle proof provides."),(0,n.kt)("p",null,"So by merging the merkle tree with the patricia trie, the Merkle Patricia Trie is able to achieve:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Efficient lookup and updates of data elements stored as key-value pairs"),(0,n.kt)("li",{parentName:"ul"},"Efficient cryptographic proofs of data integrity  ",(0,n.kt)("em",{parentName:"li"},"(i.e. Merkle roots)")),(0,n.kt)("li",{parentName:"ul"},"Efficient updates to the Merkle root",(0,n.kt)("sup",null,"1")),(0,n.kt)("li",{parentName:"ul"},"Merkle root depends only on the data contents, and not on the order they were added or changed",(0,n.kt)("sup",null,"2"))),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("em",{parentName:"li"},"We do not need to rehash the entire tree in the Merkle Patricia trie, just the parent nodes upstream to changed leaf nodes.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("em",{parentName:"li"},"In a merkle tree, swapping positions of data elements will change the Merkle root."))),(0,n.kt)("h2",{id:"performance-issues"},"Performance Issues"),(0,n.kt)("p",null,"For the sake of analyzing its performance bottlenecks, we can simplify the Merkle Patricia trie to a hexary (or 16-ary) Merkle tree. From our previous discussion on k-ary Merkle trees, we can appreciate that the proof size quickly becomes a burden. With 1,000,000 leaf nodes, we require ",(0,n.kt)("span",{parentName:"p",className:"math math-inline"},(0,n.kt)("span",{parentName:"span",className:"katex"},(0,n.kt)("span",{parentName:"span",className:"katex-mathml"},(0,n.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,n.kt)("semantics",{parentName:"math"},(0,n.kt)("mrow",{parentName:"semantics"},(0,n.kt)("mn",{parentName:"mrow"},"16"),(0,n.kt)("mo",{parentName:"mrow"},"\u2217"),(0,n.kt)("msub",{parentName:"mrow"},(0,n.kt)("mrow",{parentName:"msub"},(0,n.kt)("mi",{parentName:"mrow"},"log"),(0,n.kt)("mo",{parentName:"mrow"},"\u2061")),(0,n.kt)("mn",{parentName:"msub"},"16")),(0,n.kt)("mn",{parentName:"mrow"},"1000000"),(0,n.kt)("mo",{parentName:"mrow"},"\u224a"),(0,n.kt)("mn",{parentName:"mrow"},"80")),(0,n.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"16 * \\log_{16} 1000000 \\approxeq 80")))),(0,n.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,n.kt)("span",{parentName:"span",className:"base"},(0,n.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,n.kt)("span",{parentName:"span",className:"mord"},"16"),(0,n.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,n.kt)("span",{parentName:"span",className:"mbin"},"\u2217"),(0,n.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,n.kt)("span",{parentName:"span",className:"base"},(0,n.kt)("span",{parentName:"span",className:"strut",style:{height:"0.9386em",verticalAlign:"-0.2441em"}}),(0,n.kt)("span",{parentName:"span",className:"mop"},(0,n.kt)("span",{parentName:"span",className:"mop"},"lo",(0,n.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,n.kt)("span",{parentName:"span",className:"msupsub"},(0,n.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,n.kt)("span",{parentName:"span",className:"vlist-r"},(0,n.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.207em"}},(0,n.kt)("span",{parentName:"span",style:{top:"-2.4559em",marginRight:"0.05em"}},(0,n.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,n.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,n.kt)("span",{parentName:"span",className:"mord mtight"},(0,n.kt)("span",{parentName:"span",className:"mord mtight"},"16"))))),(0,n.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,n.kt)("span",{parentName:"span",className:"vlist-r"},(0,n.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.2441em"}},(0,n.kt)("span",{parentName:"span"})))))),(0,n.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.kt)("span",{parentName:"span",className:"mord"},"1000000"),(0,n.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.kt)("span",{parentName:"span",className:"mrel amsrm"},"\u224a"),(0,n.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,n.kt)("span",{parentName:"span",className:"base"},(0,n.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,n.kt)("span",{parentName:"span",className:"mord"},"80")))))," inner nodes for a single proof. Practically this can mean an ",(0,n.kt)("a",{parentName:"p",href:"https://notes.ethereum.org/@vbuterin/verkle_tree_eip#Motivation"},"18 MB proof size for a block"),". Verkles tries enable a ~15x reduction in proof size."),(0,n.kt)("h2",{id:"more-reading"},"More Reading"),(0,n.kt)("p",null,"If you'd like to dive deeper into the Merkle Patricia Trie, check out:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://medium.com/@chiqing/merkle-patricia-trie-explained-ae3ac6a7e123"},"Ethereum Merkle Patricia Trie Explained")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://blog.ethereum.org/2015/11/15/merkling-in-ethereum"},"Blog post by Vitalik")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/#tries-in-ethereum"},"Ethereum documentation on Merkle Patricia Tries"))))}c.isMDXComponent=!0}}]);